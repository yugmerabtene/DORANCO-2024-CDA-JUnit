#### Jour 1: MODULE-01 - Introduction et Tests Unitaires en Java
**Durée: 8 heures**

**Objectifs:**
- Comprendre les bases des tests unitaires
- Introduction à JUnit
- Écrire des tests unitaires simples

**Contenu:**

1. **Introduction aux Tests Unitaires (2 heures)**
   - Partie 1: Importance des tests unitaires (1 heure)
     - Pourquoi tester ?
     - Cycle de développement avec tests (TDD - Test Driven Development)
   - Partie 2: Principes de base des tests unitaires (1 heure)
     - Définitions et concepts

2. **Configuration de l'environnement (1 heure)**
   - Partie 1: Installation de JUnit (30 minutes)
   - Partie 2: Configuration de Maven/Gradle pour JUnit (30 minutes)

3. **Écriture de Tests Unitaires Simples (3 heures)**
   - Partie 1: Structure d'un test unitaire (1 heure)
     - Méthodes de test
     - Annotations (@Test, @Before, @After, @BeforeClass, @AfterClass)
   - Partie 2: Assertions de base (1 heure)
     - assertEquals, assertTrue, assertFalse, etc.
   - Partie 3: Tests de méthodes simples et avec exceptions (1 heure)

**Pause déjeuner (1 heure)**

4. **Exemples Pratiques (1 heure)**
   - Partie 1: Tests de méthodes simples (30 minutes)
   - Partie 2: Tests de méthodes avec exceptions (30 minutes)

5. **Outils et Pratiques Recommandées (1 heure)**
   - Partie 1: Utilisation de Mocking avec Mockito (30 minutes)
   - Partie 2: Coverage des tests avec JaCoCo (30 minutes)

---

#### Jour 2: MODULE-02 - Tests Fonctionnels en Java
**Durée: 8 heures**

**Objectifs:**
- Comprendre les tests fonctionnels
- Utiliser Selenium pour les tests d'interface utilisateur

**Contenu:**

1. **Introduction aux Tests Fonctionnels (1 heure)**
   - Partie 1: Définition et objectifs (30 minutes)
   - Partie 2: Différences avec les tests unitaires (30 minutes)

2. **Introduction à Selenium (2 heures)**
   - Partie 1: Configuration de Selenium (1 heure)
     - Installation
     - Setup de WebDriver
   - Partie 2: Structure d'un test Selenium (1 heure)
     - Éléments de base

3. **Écriture de Tests Fonctionnels (2 heures)**
   - Partie 1: Interaction avec des éléments web (1 heure)
     - Clics, saisie de texte, etc.
   - Partie 2: Assertions et vérifications sur l'interface utilisateur (1 heure)

**Pause déjeuner (1 heure)**

4. **Exemples Pratiques (2 heures)**
   - Partie 1: Tests de formulaires (1 heure)
   - Partie 2: Tests de navigation (1 heure)

5. **Outils et Pratiques Recommandées (1 heure)**
   - Partie 1: Utilisation de Page Object Pattern (30 minutes)
   - Partie 2: Exécution des tests dans différents navigateurs avec WebDriver (30 minutes)

---

#### Jour 3: MODULE-03 - Tests de Sécurité
**Durée: 8 heures**

**Objectifs:**
- Comprendre les tests de sécurité
- Utiliser OWASP ZAP pour tester les vulnérabilités

**Contenu:**

1. **Introduction aux Tests de Sécurité (1 heure)**
   - Partie 1: Importance des tests de sécurité (30 minutes)
   - Partie 2: Types de vulnérabilités courantes (XSS, SQL Injection, etc.) (30 minutes)

2. **Introduction à OWASP ZAP (2 heures)**
   - Partie 1: Installation et configuration (1 heure)
   - Partie 2: Interface et fonctionnalités de base (1 heure)

3. **Écriture de Tests de Sécurité (2 heures)**
   - Partie 1: Scans automatiques (1 heure)
   - Partie 2: Tests manuels avec ZAP (1 heure)

**Pause déjeuner (1 heure)**

4. **Exemples Pratiques (2 heures)**
   - Partie 1: Détection des vulnérabilités XSS (1 heure)
   - Partie 2: Détection des vulnérabilités SQL Injection (1 heure)

5. **Outils et Pratiques Recommandées (1 heure)**
   - Partie 1: Intégration des tests de sécurité dans le pipeline CI/CD (30 minutes)
   - Partie 2: Utilisation de rapports pour le suivi des vulnérabilités (30 minutes)

---

#### Jour 4: MODULE-04 - Tests de Non-Régression avec GitHub Actions
**Durée: 8 heures**

**Objectifs:**
- Comprendre les tests de non-régression
- Utiliser GitHub Actions pour l'automatisation des tests

**Contenu:**

1. **Introduction aux Tests de Non-Régression (1 heure)**
   - Partie 1: Importance des tests de non-régression (30 minutes)
   - Partie 2: Stratégies de mise en place (30 minutes)

2. **Automatisation avec GitHub Actions (3 heures)**
   - Partie 1: Introduction à GitHub Actions (1 heure)
     - Concepts de base
     - Avantages de GitHub Actions
   - Partie 2: Création de workflows GitHub Actions (1 heure)
     - Syntaxe et configuration de base
   - Partie 3: Configuration de runners GitHub (1 heure)
     - Types de runners (hébergés par GitHub vs auto-hébergés)

3. **Écriture de Tests de Non-Régression (2 heures)**
   - Partie 1: Réutilisation des tests unitaires et fonctionnels (1 heure)
   - Partie 2: Ajout des tests dans les workflows GitHub Actions (1 heure)

**Pause déjeuner (1 heure)**

4. **Exemples Pratiques (1 heure)**
   - Partie 1: Configuration d'un workflow CI/CD (30 minutes)
   - Partie 2: Déclenchement automatique des tests (30 minutes)

5. **Outils et Pratiques Recommandées (1 heure)**
   - Partie 1: Surveillance et analyse des résultats de tests (30 minutes)
   - Partie 2: Utilisation des artefacts et des rapports de tests (30 minutes)

---

#### Jour 5: MODULE-05 - Autres Types de Tests et Conclusion
**Durée: 8 heures**

**Objectifs:**
- Découvrir d'autres types de tests
- Synthèse et mise en pratique des connaissances

**Contenu:**

1. **Introduction aux Tests de Performance (1 heure)**
   - Partie 1: Importance des tests de performance (30 minutes)
   - Partie 2: Utilisation de JMeter (30 minutes)

2. **Introduction aux Tests de Charge (1 heure)**
   - Partie 1: Définition et objectifs (30 minutes)
   - Partie 2: Outils pour les tests de charge (Gatling, JMeter) (30 minutes)

3. **Tests de Compatibilité (1 heure)**
   - Partie 1: Importance des tests de compatibilité (30 minutes)
   - Partie 2: Stratégies et outils (30 minutes)

**Pause déjeuner (1 heure)**

4. **Conclusion et Synthèse (1 heure)**
   - Partie 1: Récapitulatif des types de tests (30 minutes)
   - Partie 2: Bonnes pratiques pour une stratégie de tests complète (30 minutes)

5. **Projet Final (3 heures)**
   - Partie 1: Mise en place d'un projet avec une couverture complète des tests (1 heure)
   - Partie 2: Exécution et analyse des résultats (1 heure)
   - Partie 3: Discussions et feedback (1 heure)

### Ressources Supplémentaires
- Documentation JUnit
- Documentation Selenium
- OWASP ZAP User Guide
- GitHub Actions Documentation
- JMeter User Guide

### Exercice Pratique
1. Créez un projet Java simple.
2. Écrivez des tests unitaires, fonctionnels, de sécurité, et de non-régression.
3. Intégrez ces tests dans un pipeline GitHub Actions.

----
MODULE-01 : 
Le Développement Piloté par les Tests (Test-Driven Development ou TDD) est une méthodologie de développement de logiciels où les tests sont écrits avant que le code de production soit développé. L'idée est de d'abord écrire un test qui échoue (car la fonctionnalité n'est pas encore implémentée), puis d'écrire le minimum de code nécessaire pour faire passer le test, et enfin de refactorer le code pour améliorer sa structure tout en s'assurant que les tests continuent de passer.

### Les Étapes du TDD

1. **Écrire un test** : Commencez par écrire un test pour une nouvelle fonctionnalité. Ce test doit décrire le comportement attendu.
2. **Faire échouer le test** : Exécutez le test pour vérifier qu'il échoue. Cela confirme que le test est valide et qu'il échoue pour la bonne raison.
3. **Écrire le code** : Écrivez le minimum de code nécessaire pour faire passer le test.
4. **Faire passer le test** : Exécutez les tests pour vérifier que le nouveau code passe le test.
5. **Refactoriser** : Améliorez la structure du code tout en vous assurant que tous les tests continuent de passer.

### Avantages du TDD

- **Qualité du code** : Le TDD encourage un design de code propre et bien structuré.
- **Détection précoce des bugs** : Les tests écrits avant le développement permettent de détecter les bugs tôt.
- **Confiance** : Les développeurs peuvent effectuer des modifications avec la confiance que les tests détecteront les régressions.
- **Documentation** : Les tests servent également de documentation vivante pour le comportement du code.

### Exemple d'Implémentation en Java

Prenons un exemple simple où nous voulons implémenter une classe `Calculator` avec une méthode `add` qui additionne deux nombres.

1. **Écrire un test** :

```java
import org.junit.Test;
import static org.junit.Assert.*;

public class CalculatorTest {
    @Test
    public void testAdd() {
        Calculator calc = new Calculator();
        int result = calc.add(2, 3);
        assertEquals(5, result);
    }
}
```

2. **Faire échouer le test** : À ce stade, si nous exécutons le test, il échouera parce que la classe `Calculator` et la méthode `add` n'existent pas encore.

3. **Écrire le code** :

```java
public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }
}
```

4. **Faire passer le test** : Maintenant, si nous exécutons le test, il devrait passer car la méthode `add` retourne la somme des deux nombres.

5. **Refactoriser** : Dans ce cas simple, il n'y a pas de refactorisation nécessaire, mais cette étape est cruciale pour les cas plus complexes afin d'améliorer la qualité du code sans changer son comportement.

### Outils pour le TDD en Java

- **JUnit** : Un framework de test pour Java qui permet d'écrire et d'exécuter des tests unitaires.
- **Mockito** : Un framework de mock pour Java, souvent utilisé pour isoler le code testé des dépendances externes.
- **IDE** : Des environnements de développement comme IntelliJ IDEA, Eclipse, ou VS Code offrent une intégration facile avec des frameworks de test comme JUnit.

